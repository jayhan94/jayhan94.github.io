# Java8并发包学习笔记之AQS

AQS是java并发工具的基础, 比如ReentrantLock, CountDownLatch, Semaphore等都是基于AQS实现的. 通过对AQS的学习, 可以帮助我们更深入了解java是如何实现这些并发工具的, 体会到并发编程的魅力.

## 获取锁
以`acquire`方法为切入点.

`acquire`的入参是一个整数值, 这个参数会作用到state上, 引发state的变化, 可以由实现者来赋予它任何具体的含义. 举个例子, 可以赋予它"次数"的含义. 对于可重入锁, 每次`acquire(1)`就将state +1, `release(1)`就将state -1, 这样state就可以清晰地表达"重入"状态.

首先线程通过`tryAcquire`尝试获取锁, 如果获取到了, 就直接返回. 否则, 进入"等待队列", 线程被挂起. `tryAcquire`需要子类实现, 默认实现是会抛异常的. 如果在等待过程中发现线程被中断, 会清除线程的中断标记位, 在获取到锁之后再将线程恢复成中断状态. 如果使用`acquireInterruptibly`接口则支持及时响应中断.

**为什么入参是一个int32, 而不是其他类型?**

因为state是一个int32, 这个参数值和state进行数学运算, 来推动state的变化. state使用int32是因为 1.cpu对int32的读写操作比较高效. 2.多数情况下, int32的取值范围是够用的. 一些特殊场景, 可以用`AbstractQueuedLongSynchronizer` -- 使用long作为状态值.

**tryAcquire的语义是什么?**

这个函数的语义是: 根据当前的状态值来决定是否可以获取到锁. 必须由获取锁的线程来执行. 如果这个函数返回失败, 且线程不在队列中, 那么线程需要排队. 这个函数的实现应该很轻, 比如对state执行+1, 会推进state的变化, 可以理解成先"占个座", 之后再继续执行更完整的逻辑.

**什么是等待队列?**

没有获取到锁的线程, 需要进入等待队列排队, 直到同步器状态允许获取时, 再对其中的线程进行唤醒.

**入队过程是什么样的?**

首先, 快速尝试一次对队尾的CAS操作, 看能否顺利入队. 这个CAS操作即是将等待队列的队尾tail的后继节点设置成当前线程节点. 如果有其他线程同时在入队, 即多个线程同时修改, 这个操作可能失败. 当fast path行不通时, 会降级到完备的入队逻辑 -- 循环CAS队尾直到成功. 这里有一个困惑, fast path快在哪里? 我们来看一下代码:
```java
private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    // Try the fast path of enq; backup to full enq on failure
    Node pred = tail;
    if (pred != null) {
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    enq(node);
    return node;
}
```
fast path可以省略一次方法调用和循环本身的开销. 且竞争不是特别激烈的情况下, 更容易内联, 编译后的代码体积更小.

**入队之后呢?**

入队之后, 会被挂起(LockSupport.park). 挂起时会设置blocker为当前的同步器, 这样stack中会显示类似于
```
java.lang.Thread.State: WAITING (parking)
	at sun.misc.Unsafe.park(Native Method)
	- parking to wait for  <0x00000007159e7758> (a example.TTest)
```
的信息, 告知我们是被哪个同步器挂起了, 可以帮助debug.

在挂起前, 有一个关键动作, 即查询/更新前驱节点的状态. 如果前驱节点的状态是*SIGNAL*, 表示当前节点已经具备被唤醒的条件, 所以可以被挂起. 否则会去设置前驱节点的状态*SIGNAL*. 如果当前节点的前驱节点是*CANCELLED*, 会跳过这些节点, 直到发现一个非*CANCELLED*前驱节点. 这个涉及到唤醒的过程对状态的判断, 细节在接下来继续研究. 所以这里引伸出一些问题, 需要在后面解决:
1. 节点状态分别有哪些含义?
2. 为什么是用前驱节点状态来决定是否唤醒当前节点?
3. 挂起后如何唤醒它?

接下来, 看下线程释放资源的过程.
## 释放锁
以`release`为切入点.

